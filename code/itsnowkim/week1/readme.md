# 내용 정리
## 그리디
그리디 카테고리에 속하는 문제의 범위가 넓기 때문에,
문제를 마주했을 때 해야 하는 일 중 하나로 가장 먼저 
해당 문제가 그리디로 접근해서 풀 수 있는지 확인하는 것이 중요하다고 생각된다.

단순 그리디 솔루션으로 풀 수 있는 문제도 있지만,
해당 솔루션을 수식화해서 더 간결하게 풀 수 있는 문제도 있다.

## 구현
네 방위에 대한 문제가 가장 대표적이다.
풀이를 보면 이해도 쉽게 되고, 아이디어도 쉽게 이해 된다.
다만, 문제로 들어가게 되면 마음처럼 쉽게 구현이 되지는 않는 것 같다.
여러 문제를 많이 풀어봐야 할 것 같다.

## 문제 풀이

### 2212 센서
문제 이해가 오래 걸렸다.

이미 존재하는 기지국이 있을 경우 추가 설치하는 시나리오라고 오해했다.
만약 그렇다면 추가되는 기지국에서 가장 가까운 곳으로 편입되는 식일 것이다.

보자마자 편의를 위해 정렬이 필요했다.
그 후, k=1일 때부터 2일때, 3일 때,,, 로 생각해서 확장해 나갔다.

만약 세울 수 있는 기지국이 하나라면, 모든 거리 차의 합일 것이다.
만약 세울 수 있는 기지국이 두 개라면, 모든 거리의 차에서 가장 긴 길이를 제거하면 될 것이다.
이 때, 가장 긴 거리가 두 개 이상이라도 거리의 합을 구하는 문제이기 때문에 어떤 것을 제거해도 문제가 되지 않는다.
만약 세울 수 있는 기지국이 세 개라면, 가장 길이가 긴 것 부터 2 개를 제거하면 될 것이다.

이처럼 greedy하게 접근하면 풀리는 문제라고 생각했다.

따라서 거리의 차를 구하는 리스트를 만들었고, 해당 거리의 차를 정렬했다.
그 후, 거리의 합에 더하지 않아도 되는 것들을 제외하고 합을 구했다.

>실패 로그, 질문
처음에는 중복되는 좌표의 경우 하나만 남기고 제거했다. 왜 틀렸는지 아직 이해가 되지 않는다.
https://www.acmicpc.net/source/57066182

### 15683 감시
어려움 - 아직 풀이중

### 프로그래머스 150369 택배 배달과 수거하기
처음에는 테스트케이스 2번을 통과하지 못했다.

기본적인 아이디어는 "가장 멀리 있는 것 부터 배달하고, 가져온다" 였다.
가장 멀리 배달, 수거해야 하는 index를 각각 저장하고,
배달과 수거를 거칠 때마다 해당 index를 업데이트해 주었다.

테스트케이스 2번의 경우, 배달과 수거를 할 필요가 없는 케이스였다.
따라서, 가장 먼 곳에 있는 배달과 수거가 필요한 index를 구하고, 
해당 index의 최댓값이 0일 경우 바로 return하도록 코드를 수정했다.
그랬더니 됐다.

뭔가 한 가지 테스트케이스만 안 되는 경우, 이처럼 극단적인 경우도 생각해 봐야 한다는 것을 일깨워 주었다.

### 프로그래머스 150368 이모티콘 할인행사
두 가지 핵심 조건이 있었다.
1. 가입자를 최대로 할 것
2. 최대의 판매이익일 것

이 두 가지 조건에서 바로 
```python
if register_user_count < user_count:
    register_user_count = user_count
    max_price = sum_price
elif register_user_count == user_count and max_price < sum_price:
    max_price = sum_price
```
를 떠올리게 되었다.

이모티콘의 할인률은 10, 20, 30, 40 딱 네 가지뿐이라는 점과,
여러 할인률을 적용하여 이모티콘을 판매했을 때 각각의 케이스에서 가입자 수와 총액이 나온다는 점에서
먼저 이모티콘에 할인을 적용해서, 이모티콘 판매액의 모든 경우의 수를 만들어야 한다고 생각했다.

python 조합을 검색했는데,
https://theoldface-dev.tistory.com/m/57
얘가 나와서 해당 코드를 참고했다.


