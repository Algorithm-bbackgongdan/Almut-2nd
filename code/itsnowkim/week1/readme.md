# 내용 정리
## 그리디
그리디 카테고리에 속하는 문제의 범위가 넓기 때문에,
문제를 마주했을 때 해야 하는 일 중 하나로 가장 먼저 
해당 문제가 그리디로 접근해서 풀 수 있는지 확인하는 것이 중요하다고 생각된다.

단순 그리디 솔루션으로 풀 수 있는 문제도 있지만,
해당 솔루션을 수식화해서 더 간결하게 풀 수 있는 문제도 있다.
## 구현


## 문제 풀이

### 2212 센서
문제 이해가 오래 걸렸다.

이미 존재하는 기지국이 있을 경우 추가 설치하는 시나리오라고 오해했다.
만약 그렇다면 추가되는 기지국에서 가장 가까운 곳으로 편입되는 식일 것이다.

보자마자 편의를 위해 정렬이 필요했다.
그 후, k=1일 때부터 2일때, 3일 때,,, 로 생각해서 확장해 나갔다.

만약 세울 수 있는 기지국이 하나라면, 모든 거리 차의 합일 것이다.
만약 세울 수 있는 기지국이 두 개라면, 모든 거리의 차에서 가장 긴 길이를 제거하면 될 것이다.
이 때, 가장 긴 거리가 두 개 이상이라도 거리의 합을 구하는 문제이기 때문에 어떤 것을 제거해도 문제가 되지 않는다.
만약 세울 수 있는 기지국이 세 개라면, 가장 길이가 긴 것 부터 2 개를 제거하면 될 것이다.

이처럼 greedy하게 접근하면 풀리는 문제라고 생각했다.

따라서 거리의 차를 구하는 리스트를 만들었고, 해당 거리의 차를 정렬했다.
그 후, 거리의 합에 더하지 않아도 되는 것들을 제외하고 합을 구했다.

>실패 로그, 질문
처음에는 중복되는 좌표의 경우 하나만 남기고 제거했다. 왜 틀렸는지 아직 이해가 되지 않는다.
https://www.acmicpc.net/source/57066182

### 15683 감시
어려움

### 프로그래머스 150369 택배 배달과 수거하기
처음에는 테스트케이스 2번을 통과하지 못했다.

기본적인 아이디어는 "가장 멀리 있는 것 부터 배달하고, 가져온다" 였다.
가장 멀리 배달, 수거해야 하는 index를 각각 저장하고,
배달과 수거를 거칠 때마다 해당 index를 업데이트해 주었다.

테스트케이스 2번의 경우, 배달과 수거를 할 필요가 없는 케이스였다.
따라서, 가장 먼 곳에 있는 배달과 수거가 필요한 index를 구하고, 
해당 index의 최댓값이 0일 경우 바로 return하도록 코드를 수정했다.
그랬더니 됐다.

뭔가 한 가지 테스트케이스만 안 되는 경우, 이처럼 극단적인 경우도 생각해 봐야 한다는 것을 일깨워 주었다.


