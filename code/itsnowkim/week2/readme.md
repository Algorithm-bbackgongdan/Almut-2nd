# 공부

## 인접 행렬과 인접 리스트
인접 행렬
- 모든 관계를 저장한다.
- INF = 99999 와 같은 식으로 연결되지 않은 간선을 표현한다.
노드 개수가 많을수록 메모리가 불필요하게 낭비된다.

인접 리스트
- 연결된 정보만을 저장한다.
- python에서는 리스트로 구현한다.

메모리를 효율적으로 사용한다.
특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다.
연결된 데이터를 하나씩 확인해야 하기 때문. O(n) (해당 노드에 있는 연결 개수 = n)

## DFS
dfs는 스택 자료구조를 이용한다.
최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작한다.

구체적인 동작 과정
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. 위의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
>
방문 처리는 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것을 의미한다. 방문 처리를 함으로써 각 노드를 한 번씩만 처리할 수 있다.

## BFS
bfs는 큐 자료구조를 이용한다.
가까운 노드부터 탐색하는 알고리즘이다.
인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 된다.

구체적인 동작 과정
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 위의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
>
큐 자료구조에 기초한다. `deque` 라이브러리를 사용하여 구현한다. 일반적인 코딩 테스트에서는 보통 dfs보다 bfs 구현이 조금 더 빠르게 동작함을 기억하자.

# 문제풀이
## 16234 - 인구이동
bfs, dfs 전형적인 문제라기보다, 구현에 가까운 문제라고 생각한다.

다음과 같은 step으로 풀었다.
1. 국경을 열 수 있는지 check해서, 열 수 있는 국가의 head를 저장
2. 해당 head로부터 bfs 알고리즘으로 어떤 국가들이 열리는지 확인
3. 2번까지 결과를 바탕으로 나라별 인구 수 한 번에 업데이트
4. 위 행위 반복

처음에 test case 3번에서 오답이 나왔었는데, 나라별 인구 수를 한 번에 업데이트하지 않고 순차적으로 업데이트 하면서 생기는 오류였다.

다만, 지금 제출하면 80%에서 시간 초과가 나오는데, 이 부분을 개선해야 한다.

## 1744
쉬운 문제였다.
단순히 정렬한 후 조건에 따라 더해주기만 하면 되는 문제였다.

다만, 한 가지 얻어가는 것이 있었는데, python에서 for 문을 돌 때
index를 1씩 증가시키지 않고 2씩 혹은 그 범위를 지정할 수 있다.

이 문법이 있다는 것을 알고는 있었지만 익숙하지 않았는데, 이번에 확실히 배워간다.

특별히 고려해야 할 점이라면 0이 있을 때와 1이 있을 때 예외 처리를 해 주는 것일 것 같다.


## 프로그래머스 150370 - 개인정보 수집 유효기간
쉬웠다. 단순히 문자열 parsing 후에 계산만 하면 되는 문제였다.
따로 comment할 게 없다.

## 프로그래머스 150367 - 표현 가능한 이진트리
문제의 개요는 쉽게 떠올렸다.
순서는 다음과 같다.
1. 수를 이진수로 만든다.
2. 해당 이진수로 full binary tree를 만든다.
3. 2의 과정에서 불가능하다면 0을 return한다.

2와 3은 문제를 그대로 이해하고, 하라는 대로 쉽게 했지만,
1번에서 막혔다. 사실 단순히 이 또한 하라는 대로 했으면 성공했을 것 같다.

하지만, 수를 이진수로 바꾸는 과정에서 단순히 `format()` 함수를 사용했는데,
이렇게 하면 0이 맨 앞에 오는 예외 처리를 할 수 없었다.

그래서 결국 검색해서 답을 찾아보게 되었는데, 허무하기도 했고 문제를 잘 읽는 것이 중요할 것 같다.