# 1. BOJ 16234

## 접근 방법

1. **국경을 연 국가** 에 대해 계속 주변 국가의 인구를 확인해야 한다. 따라서 BFS로 큐에 **국경을 연 국가** 를 넣어서 구현하였다.

2. 이미 이전에 탐색된 국가는 굳이 탐색할 필요가 없다. 따라서 **국경을 연 국가** 는 `visited`처리를 해주었다. `visited`가 `True`인 국가는 탐색할 필요가 없다.

3. `L <= 모든 국가의 인구 수 차이 <= R`인 경우 탐색을 종료한다. 이 조건을 만족하는 경우는, 모든 국가가 국경을 열지 않은 경우이다. 따라서 `국경을 열지 않은 국가의 수 == 전체 국가의 수` 일 때 탐색을 종료하였다.

## 문제 회고

1. 골드 5라서 어렵지 않을 줄 알았는데 은근 구현이 빡셌다. bfs로 상하좌우로 돌면서 범위 체크하는 주제는 자주 나오는 것 같다.

2. 종료 조건이 `국경을 열지 않은 국가의 수 == 전체 국가의 수` 인게 마음에 들지 않는다. 더 나이스한 조건이 있을 것 같다.

<br />

# 2. BOJ 1744

## 접근 방법

1. 최대한 크게 만들어야 하니, 정렬하고 큰 순서대로 묶자.

2. 우선 `음수, 0, 양수` 세 가지로 나누자.

3. 음수, 양수에서 두 개 씩 묶다보면 묶지 못하고 남은 수가 있을 수 있다.

   - 양수는 무조건 0또는 음수와 묶지 않고 더하는 게 낫다 -> 남은 양수는 그냥 더하자
   - 음수는 0이 있으면 0을 곱하고 없으면, 그냥 더해야 한다. -> 음수는 0이 없을 경우 더하자

4. 숫자를 묶을 때는 인접한 숫자를 곱하는 것보다 더하는 게 큰 경우도 있다.
   - `(1, 1)` 일 경우 그렇다.
   - 따라서 더 큰 값으로 더해준다.

## 문제 회고

1. 아이디어만 떠올리면 어렵지 않은 문제였다.

2. 다만, `(1, 1)`일 경우엔 곱하는 것보다 더하는 게 크다는 엣지케이스를 생각하지 못해서 한번 틀렸다 (...ㅠㅠ). 엣지 케이스를 잘 생각하자

<br />

# 3. Programmers 150370

## 접근 방법

1. 요구 사항에 충실히 따라 구현만 하면 되겠다. 모든 날짜는 `일` 로 변환하자.

2. 약정 일자와 현재 일자의 차이를 구한다.

3. 한 달은 28일로 정해졌으므로, `연 월 일`을 `일`로 변환하고, 그 차이를 구하자

4. 그 차이와 약정 기간을 비교한다.

## 문제 회고

1. 간단하게 구현만 하면 된다.

2. 년, 월, 일을 일(days)로 바꾸는 과정에서 숫자가 터지지 않을까 걱정했는데, 다행히 년이 2022년까지로 주어져서 그럴 일은 없었다. 이번엔 괜찮았지만 앞으로도 범위 체크를 잘 하자.

# 4. Programmers 150367

## 접근 방법

1. 포화이진 트리로 만들라고 했으니, 앞자리에 0을 더해서 포화 이진 트리로 만들어 주자.

2. 포화 이진 트리로 만들면 항상 루트의 서브트리도 포화 이진 트리이다.

3. `leftSubtree`와 `rightSubtree`가 조건을 만족하면, `leftSubtree`와 `rightSubtree`를 자식으로 하는 트리도 조건을 만족한다.

4. 따라서 `leftSubtree`, 루트, `rightSubtree` 를 분할 정복하면 되지 않을까...?

5. 루트 노드가 더미노드면, 자식 노드는 1(기존 노드)일 수가 없다. 따라서 이런 경우는 조건을 만족하지 않으므로 `False` 리턴

6. 5.의 경우가 아니면 `leftSubtree`, `rightSubtree`에 대해 분할 정복을 한다. 둘 다 조건을 만족하면 `True`를 리턴한다.

## 문제 회고

1. 포화 이진 트리로 만들어야 한다는 조건을 놓치고 초반에 삽질을 좀 했다... 문제의 조건을 잘 읽자.

2. 코테 문제에서 분할 정복을 풀어본 게 처음인 것 같은데 재밌다. (더 나와줘...! 물론 쉽게 ㅎㅎ)

3. 리턴 값을 정하는 게 까다로웠다. 특정 조건을 만족하면 `True` 이런 식으로 생각했는데... 심플하게 재귀를 리턴하면 됐다!
