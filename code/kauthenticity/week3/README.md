## 1. BOJ 2243

### 접근 방법

1. 블루레이 크기는 `최대 강의 길이` ~ `모든 강의를 합한 길이` 로 오름차순 정렬이 가능하므로 이분 탐색이 가능하다.

2. 현재 블루레이 크기에 대해 만들어지는 블루레이 개수를 구한다.

3. 블루레이가 m개 보다 적게 만들어지면 블루레이 크기를 줄여야 한다.

4. 블루레이가 m개 보다 많이 만들어지면 블루레이 크기를 늘려야 한다.

### 문제 회고

1. 이분탐색을 할 때마다 느끼는 거지만 마지막에 mid를 바꾸는 과정이랑 low, mid, high 중 어떤 것을 정답 값으로 할지가 헷갈린다.

2. 이번엔 어쩌다 떄려맞췄는데 이분탐색 연습을 더 해야겠다.

<br />

## 2. BOJ 2240

### 접근 방법

1.  `dp[i][j]` => i초에서 j번 움직였을 떄 얻을 수 있는 최대 사과 개수
2.  각 초에서는 가만히 있을 경우, 이동한 경우 두 가지로 나뉜다.
3.  따라서 `dp[i][j]`는 둘 중 큰 값으로 저장한다.
4.  `j`번 움직였을 때 짝수 번 움직이면 1번, 홀수 번 움직이면 2번이다.

### 문제 회고

1. 처음에 식 정의를 잘 해서 그런지 어렵지 않았다.

2. 다만 안쪽 루프의 경우 `min(w + 1, i + 1)`로 `min(최대 이동 가능 횟수, i초 전부 움직인 횟수)` 를 따져야하는 디테일이 필요했다.

<br />

## 3. Programmers 150365

### 접근 방법

1. 1<=`k`<=2500 으로, 4^2500개의 경우의 수다. dfs나 bfs로 풀면 스택이나 힙이 터진다.

2. 사전순이라는 조건에 유의하여 그리디하게 풀자.

3. 장애물이 없으므로 현재점 ~ 도착점의 거리는 맨해튼 거리와 같다.

4. `k < 맨해튼 거리`인 경우 애초에 도달할 수 없으므로 프로그램을 종료한다.

5. `k > 맨해튼 거리`인 경우(돌아가도 되면) 굳이 최적으로 움직이지 않아도 된다. 따라서 d, l, r, u 순서대로 움직일 수 있는지 확인하고 가능하면 움직인다.

6. `k == 맨해튼 거리`인 경우 최적으로 움직여야 한다. 현재 점과 도착점을 이은 벡터의 방향에 따라 d, l, r, u 중 최적의 방향을 찾는다.

### 문제 회고

1. dfs나 bfs로 풀면 메모리가 터진다는 건 알았는데 다른 방법이 떠오르지 않았다 ㅠㅠ. 어쩔 수 없이 질문하기 페이지를 참고하였다.

2. 장애물이 없으므로 최적으로 움직이는 거리는 맨해튼 거리라는 아이디어가 굉장히 신박했다!

3. 메모리가 터지면 문제의 조건을 다시 살피면서 다른 방법이 없는지 곰곰이 생각해 보자.

## 4. Programmers 118667

### 접근 방법

1. 각 큐의 합을 구해서 합이 더 작은 쪽으로 그리디하게 옮긴다.
2. 큐의 합이 같아지면 종료한다.
3. 이때 `queue1 = [1, 1, 1, 10000]`, `queue2 = [1]` 인 경우 결국엔 `queue1`이 `empty`가 되므로 이런 경우에 대한 예외 처리가 필요하다.
4. 계속 옮기다 처음과 같아지면 이는 두 큐의 합을 같게 만들지 못하는 경우다.

   4-1. 즉, `queue1`의 모든 원소가 pop되고 다시 push돼야 하고 (`2*len(queue1)`)

   4-2. `queue2`의 모든 원소가 pop되고 다시 push돼야 하므로 (`2*len(queue2)`)

   4-3. `2*(len(queue1) + len(queue2))`번 넘게 반복하면 종료하자.

### 문제 회고

1. 처음에는 while문 안에서 계속 각 큐의 합을 구했다. 그랬더니 일부 케이스가 시간 초과가 떴다.

2. 근데 큐가 어떻게 변경되는지 알고 있으므로 그냥 처음에만 합을 구하고 거기에 더하거나 빼자

3. 시간 초과 해결 완료!

4. 불필요한 연산은 피하는 게 좋겠다.
