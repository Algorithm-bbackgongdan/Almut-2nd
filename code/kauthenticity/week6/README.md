## 1. Programmers 92343

### 접근 방법

1. 이 문제는 일반적인 dfs와 다르게 갔던 점을 또 가도 된다. (사실상 가야 한다.)

 <img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ed7118a9-a99b-4f3a-9779-a94816529e78/03_2022_%E1%84%80%E1%85%A9%E1%86%BC%E1%84%8E%E1%85%A2%E1%84%86%E1%85%AE%E1%86%AB%E1%84%8C%E1%85%A6_%E1%84%8B%E1%85%A3%E1%86%BC%E1%84%80%E1%85%AA%E1%84%82%E1%85%B3%E1%86%A8%E1%84%83%E1%85%A2_01.png" width=500>

2. `0`을 방문한 후에 갈 수 있는 점은 `1`, `8`이다.

3. 여기서 `1`을 선택했다 치면, `2`, `4`로 내려가거나, `0`으로 돌아가서 `8`로 갈 수 있다. 즉 이동할 수 있는 점은 `[2, 4, 8]`이다.

4. 이렇게 이동할 수 있는 점들을 갱신해 나면서 다음 점으로 이동한다.

5. 더 이상 이동할 점이 없을 때에는 현재 양의 개수와 최대 양의 개수를 비교한다.

### 회고

1. 별 이상하게 삽질을 많이 한 문제다. 그리디하게 양을 왕창 모아야 하나...? 고민도 했다.

2. 이 문제의 핵심은 양을 모으고, 방문했던 점으로 또 내려가도 된다는 것이다.

3. 뭐 `visited`를 갱신하고 이런 거 필요 없이 **내가 있는 점에서 이동할 수 있는 점** 리스트를 maintain하면 됐다. 그럼 내 형제 노드라도, 부모를 타고 갈 필요 없이 바로 확인할 수 있다!

4. 굉장히 아이디어가 중요한 문제 같다... 현장에서 이 문제 만났으면 못 풀었을 것 같다.

## 2. Programmers 42860

### 접근 방법

1. 조이스틱은 이동은 상하(알파벳 변경), 좌우(위치 변경)로 나눌 수 있다.

2. 상하 이동은 간단하게 A에서 가는게 가까운지, Z에서 가는게 가까운지 비교한다.

3. 이제 좌우가 문젠데... 우선 최대 좌우 이동 횟수가 `n-1`임은 분명하다. 이보다 작게 이동할 수 있는지 확인해야 한다.

4. 가장 긴 연속된 A를 찾는다. 연속된 A에 대해 다음 5, 6 두 가지 경우의 수가 있다.

5. 처음 -> 연속된 A 왼쪽 -> 처음 -> 연속된 A 오른쪽

6. 처음 -> 연속된 A 오른쪽 -> 처음 -> 연속된 A 왼쪽

7. 그래서 `n-1`과 `5.의 이동 횟수`, `6.의 이동 횟수` 중 최소 값을 좌우 이동 횟수로 잡으면 된다.

8. 이게 답이 되는 이유는, **가장 긴 연속된 A**를 제외하고는 무조건 지나가야 하기 때문이다.

### 회고

1. 문제의 그리디 카테고리만 보고, 현재 위치에서 A가 아니면서 가장 가까운 알파벳으로 이동하는 방식으로 풀었다.

2. 역시 그리디는 옵티멀을 보장하지 못한다. 틀렸지만 아무리 생각해도 모르겠다. 구글링 어게인...

3. 너무 나이스한 풀이법이 있었다. 연습을 왕창 하면 이런 아이디어를 낼 수 있는지 의문이 든다.

## 3. Programmers 67259

### 접근 방법

1. bfs와 dp에 다익스트라 느낌을 섞어서 (ㅋㅋㅋㅋ) 풀었다.

2. dp 배열은 다음과 같이 정의했다. `costs[i][j][k]` -> `(i, j)`로 k 방향으로 갈 때의 최소 비용

3. 처음에 `(0, 0)`을 큐에 넣는다.

4. 큐를 pop하고 인접한 점에 대해 현재 점을 거쳐서 가는게 더 거리가 짧을 경우엔 `costs` 배열을 갱신해 준다. (다이스트라 느낌)

5. 큐가 empty일 때 종료한다.

### 회고

1. 이것도 완전히 내 힘으로 풀지는 못했다. dp를 2차원 배열로 정의했는데, 몇 개 tc에서 틀려서 보니깐 3차원으로 방향까지 고려를 해 줘야 했다.

2. 온갖 알고리즘을 짬뽕한 이상하지만 멋진 문제였다. 다만 방향에 따라 dp 값이 달라질 수 있다는 것을 고려하지 못한 점은 분명히 아쉬웠다.

3. TC를 손으로 따라가 보면서 다양한 경우를 생각하는 연습을 해야겠다.
