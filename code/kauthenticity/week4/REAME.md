## 1. BOJ 117799

### 접근 방법

1. 한 점에서 다른 점으로 가는 최단 경로이므로 다익스트라를 사용한다.

2. 특별한 점은 최단 경로의 길이 뿐만 아니라 경로 자체도 구해야 한다.

3. `path` 배열을 둬서, `path[i]`: 출발점이 `src`, 도착점이 `i`인 최단 경로 리스트를 저장하였다.

### 문제 회고

1. 아무리 생각해도 맞게 짠 거 같은데 왜 틀렸나 했더니... 경로 리스트를 그대로 출력한 거시어따.

2. 문제를 다 풀어놓고 출력 형식을 못 맞춰서 틀리면 너무 억울하다. 사소하지만 너무나도 중요한 출력 형식을 잘 지키자.

3. 나는 모든 정점 별로 path 리스트를 저장했는데, 그냥 부모 정점만 저장하는 방식도 있었다. 이게 메모리도 덜 먹고 훨씬 깔끔한 것 같다.

<br />

## 2. BOJ 1956

### 접근 방법

1. 최소 사이클을 찾아야 하므로 모든 정점 사이의 거리를 구해야 한다.

2. 정점이 `400`개밖에 없으므로 `400^3` = `64*10^3` 으로 플로이드 워셜을 사용해도 된다.

3. 플로이드 워셜로 모든 최단 거리를 구하고, 그 중 최소 사이클을 찾는다.

### 문제 회고

1. 문제 카테고리를 보지 못했다면 아이디어가 안 떠올랐을 것 같다.

2. 정점 개수에 유의하여 어떤 알고리즘을 적용할 지를 생각하자.

<br />

## 3. Programmers 92341

### 접근 방법

1. 단순한 구현이다.

2. 자동차 번호가 `key`, 입출차 정보를 `value로` 하는 `dictionary`를 구현한다. 이때 `records`의 원소 시각은 오름차순으로 정렬되어 주어지므로 그냥 순서대로 입출차 정보를 넣어준다.

3. 입차, 출차 시간의 차를 구하고 요금을 구한다.

### 문제 회고

1. 특별한 건 없었던 문제다.

2. 입출차 정보가 시간 순서대로 주어지지 않은 경우엔 좀 복잡했을 것 같다. 문제에 명시돼서 다행이다.

<br />

## 4. Programmers 92342

### 접근 방법

1. 현재 점수를 얻거나, 얻지 않거나 이므로 완전 탐색을 하자.

2. "정답이 여러 개인 경우, 낮은 점수를 많이 맞힌 경우를 정답으로 한다." 요 조건이 까다롭다.

3. 두 개의 info 배열을 0점부터 돌면서 낮은 점수를 더 많이 맞훈 info를 정답으로 한다.

### 문제 회고

1. 예전에 풀었던 문제인데도 시간을 많이 썼다.

2. "둘 다 몾 맞추면 점수를 얻지 못함" 요 조건을 빼먹어서 점수 계산이 이상하게 됐다...

3. 아무리 생각해도 카카오는 문제가 거의 비문학이다. 조건도 너무 많다. 문제의 조건을 잘 보는 연습을 해야겠다.

4. 요 문제에선 리스트를 복사할때 slicing할지 deepcopy 모듈을 사용할지 고민했다. 근데 slicing이 100배 정도 빠르더라... 리스트 복사할 땐 slicing이 좋겠다.
