# Week 3

# 2343: ê¸°íƒ€ ë ˆìŠ¨
- ì¶œì²˜ : ë°±ì¤€
## ğŸ˜Â Solved Code

### ğŸ’» Code

```python
import sys

def calc_bluerays_number(length):
  count = 1
  curr_blueray_length = 0
  for video in videos:
    if curr_blueray_length + video > length:
      curr_blueray_length = 0
      count += 1
    curr_blueray_length += video
  return count

N, M = map(int, sys.stdin.readline().rstrip().split(' '))
videos = list(map(int, sys.stdin.readline().rstrip().split(' ')))

left = max(videos)
right = sum(videos)

while left <= right:
  mid = (left + right) // 2
  bluerays_number = calc_bluerays_number(mid)
  if bluerays_number <= M:
    right = mid - 1
  else:
    left = mid + 1

print(left)
```

### â—ï¸ ê²°ê³¼

ì„±ê³µ

### ğŸ’¡Â ì ‘ê·¼

Mê°œë¡œ ë‚˜ëˆ ë‹´ë˜ ë¸”ë£¨ë ˆì´ ê¸¸ì´ë¥¼ ìµœì†Œë¡œ í•´ì•¼í•œë‹¤. ë¹„ë””ì˜¤ë“¤ì„ Mê°œë¡œ ë‚˜ëˆ  ë‹´ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ë– ì˜¬ë¦¬ê¸°ë€ ë„ˆë¬´ ë§ë‹¤. ë”°ë¼ì„œ ì´ë¶„íƒìƒ‰ìœ¼ë¡œ ì ‘ê·¼í•œë‹¤. ê·¸ëŸ¼ ë¸”ë£¨ë ˆì´ ê¸¸ì´ë¥¼ ì´ë¶„íƒìƒ‰ í•´ì•¼ í•  ê²ƒì´ë‹¤.

ê°€ëŠ¥í•œ ë¸”ë£¨ë ˆì´ ê¸¸ì´ ë²”ìœ„ëŠ” `ë¹„ë””ì˜¤ ì¤‘ ìµœëŒ€ê¸¸ì´` ~ `ëª¨ë“  ë¹„ë””ì˜¤ì˜ ê¸¸ì´ í•©` ì¼ ê²ƒì´ë‹¤. ì¦‰, Mê°œì˜ ë¸”ë£¨ë ˆì´ë¡œ ë‹´ëŠ” ê²½ìš°ë¶€í„° 1ê°œì˜ ë¸”ë£¨ë ˆì´ë¡œ ë§Œë“œëŠ” ê²½ìš°ê°€ ë²”ìœ„ì´ë‹¤.

ê°ê°ì„ left, rightë¡œ ë‘ê³  `mid = (left + right) // 2` ë¥¼ ê³„ì‚°í•´ ì´ë¶„íƒìƒ‰ì„ ì§„í–‰í•œë‹¤.

ì–´ë–¤ ê¸°ì¤€ì— ë”°ë¼ left = mid + 1 ë˜ëŠ” right = mid -1 ë¡œ ë²”ìœ„ë¥¼ ì¢í˜€ë‚˜ê°ˆ ê²ƒì´ë‹¤.

ê·¸ ê¸°ì¤€ì´ ë¬´ì—‡ì¼ê¹Œ?

ë¹„ë””ì˜¤ ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœíšŒí•˜ë©° mid ê¸¸ì´ì˜ ë¸”ë£¨ë ˆì´ë¥¼ ë§Œë“¤ì–´ë³¸ë‹¤. ê·¸ëŸ¼ ë¸”ë£¨ë ˆì´ ê°œìˆ˜ê°€ ë‚˜ì˜¬ ê²ƒì´ë‹¤. 

ë§Œì•½ ë¸”ë£¨ë ˆì´ ê°œìˆ˜ê°€ Më³´ë‹¤ ë§ë‹¤ë©´? ê°œìˆ˜ë¥¼ ì¤„ì—¬ì•¼ í•  ê²ƒì´ë‹¤. ì¦‰, ë¸”ë£¨ë ˆì´ ê¸¸ì´ê°€ ë„ˆë¬´ ì§§ì€ ë“¯ í•˜ë‹ˆ ê¸¸ì´ë¥¼ ëŠ˜ë ¤ì•¼ í•œë‹¤. ë”°ë¼ì„œ left = mid + 1 ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.

ë§Œì•½ ë¸”ë£¨ë ˆì´ ê°œìˆ˜ê°€ Më³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤ë©´? ê°œìˆ˜ë¥¼ ëŠ˜ë ¤ì•¼ í•  ê²ƒì´ë‹¤. ì¦‰, ë¸”ë£¨ë ˆì´ ê¸¸ì´ë¥¼ ì¤„ì—¬ì•¼ í•œë‹¤. ê°œìˆ˜ê°€ Mê³¼ ê°™ë‹¤ê³  í•˜ë”ë¼ë„ ìš°ë¦° ìµœì†Œê¸¸ì´ë¥¼ êµ¬í•´ì•¼ í•˜ë¯€ë¡œ ê°€ëŠ¥í•œ ê¸¸ì´ë¥¼ ì¤„ì—¬ì•¼ í•œë‹¤. ë”°ë¼ì„œ right = mid - 1 ë¡œ ì—…ë°ì´íŠ¸ í•œë‹¤.

ë£¨í”„ë¥¼ íƒˆì¶œí•˜ëŠ” ìˆœê°„ì€ left == right + 1ì´ ë˜ëŠ” ìˆœê°„ì´ë‹¤. ì´ ë§ì€ ìµœì†Œê¸¸ì´ë¥¼ ë°œê²¬í–ˆë‹¤ëŠ” ëœ»ì´ë©°, leftê°’ì´ ë°”ë¡œ ë‹µì´ ëœë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.

## ğŸ¥³ ë¬¸ì œ íšŒê³ 

ì ‘ê·¼ì€ ë§ê²Œ í–ˆìœ¼ë‚˜ ì •ë‹µì„ midë¼ê³  ì¶œë ¥í•´ í‹€ë ¸ì—ˆë‹¤. left, rightì˜ ì˜ë¯¸ë¥¼ ìƒê°í•´ë³´ë©´ leftê°€ ì •ë‹µì´ ë ìˆ˜ë°–ì— ì—†ì—ˆë‹¤. ì¢‹ì€ ì´ë¶„íƒìƒ‰ ë¬¸ì œì¸ ê²ƒ ê°™ë‹¤.


# 2240: ìë‘ë‚˜ë¬´
- ì¶œì²˜ : ë°±ì¤€
## ğŸ˜Â Solved Code

### ğŸ’» Code

```python
import sys

T, W = map(int, sys.stdin.readline().rstrip().split(' '))
Jadu = [[0, 0] for _ in range(T + 1)]
for i in range(T):
    tree = int(sys.stdin.readline().rstrip())
    Jadu[i + 1][tree - 1] = 1

# (T + 1) * (W + 1) 2ì°¨ì› ë¦¬ìŠ¤íŠ¸
DP = [[0] * (W + 1) for _ in range(T + 1)]

# ì´ˆê¸°í™”
for w in range(W + 1):
    DP[T][w] = Jadu[T][w % 2]

for t in range(T - 1, -1, -1):
    for w in range(W, -1, -1):
        DP[t][w] = Jadu[t][w % 2] + max(DP[t + 1][w:])

print(DP[0][0])
```

### â—ï¸ ê²°ê³¼

ì„±ê³µ

### ğŸ’¡Â ì ‘ê·¼

ìš°ì„  1,2ë²ˆ ë‚˜ë¬´ì— ëŒ€í•´ Tì´ˆì— ë–¨ì–´ì§€ëŠ” ìë‘ì˜ ìˆ˜ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì €ì¥í–ˆë‹¤.

```java
Jadu = [[0,0],[0,1],[1,0], ... ,[1,0]] // (T+1) x 2 2ì°¨ì› ë¦¬ìŠ¤íŠ¸
```

Jadu[t][0]ì—ëŠ” tì´ˆì— 1ë²ˆ ë‚˜ë¬´ì— ë–¨ì–´ì§€ëŠ” ìë‘ ê°œìˆ˜, Jadu[t][1]ì—ëŠ” tì´ˆì— 2ë²ˆ ë‚˜ë¬´ì—ì„œ ë–¨ì–´ì§€ëŠ” ìë‘ ê°œìˆ˜ë£° ì €ì¥í•œ ê²ƒì´ë‹¤.

tì´ˆì— wë§Œí¼ ì´ë™í•œ ìƒí™©ì—ì„œ ë°›ì„ ìˆ˜ ìˆëŠ” ìë‘ì˜ ìµœëŒ€ ê°œìˆ˜ë¥¼ DP[t][w] ë¼ê³  í•˜ì. ê·¸ëŸ¼ ìš°ë¦¬ê°€ êµ¬í•  ë‹µì€ DP[0][0]ì¼ ê²ƒì´ë‹¤. ì´ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ Top-down ìœ¼ë¡œ 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ DPë¥¼ ì±„ì›Œë‚˜ê°€ë©´ ëœë‹¤.

ê°€ì¥ Topì— í•´ë‹¹í•˜ëŠ” ê°’ DP[T][W], DP[T][W-1], â€¦ , DP[T][0] ì€ ì–´ë–»ê²Œ êµ¬í•  ìˆ˜ ìˆì„ê¹Œ?

ë‚˜ë¬´ê°€ ë‘ ê°œ ì´ë¯€ë¡œ í˜„ì¬ê¹Œì§€ ì´ë™í•œ íšŸìˆ˜ wê°€ í™€ìˆ˜ë¼ë©´ 2ë²ˆ ë‚˜ë¬´ì—, ì§ìˆ˜ë¼ë©´ 1ë²ˆ ë‚˜ë¬´ì— ìœ„ì¹˜í•  ê²ƒì´ë‹¤. ìš°ë¦¬ëŠ” ë§ˆì§€ë§‰ ì´ˆ(Tì´ˆ)ì— ì–´ëŠ ë‚˜ë¬´ì—ì„œ ìë‘ê°€ ë–¨ì–´ì§€ëŠ”ì§€ ì•Œê³  ìˆê¸° ë–„ë¬¸ì— ì´ˆê¸°ê°’ì„ ì •í•˜ëŠ” ë°ì— í° ì–´ë ¤ì›€ì´ ì—†ë‹¤.

ë”°ë¼ì„œ ì•„ë˜ì™€ ê°™ì´ ì´ˆê¸°í™” í•  ìˆ˜ ìˆë‹¤.

```java
for w in range(W + 1):
    DP[T][w] = Jadu[T][w % 2]
```

ì´ì œ Top-downìœ¼ë¡œ DPë¥¼ ì ìš©í•  ìˆ˜ ìˆë‹¤. ì•„ë˜ì™€ ê°™ë‹¤.

```java
for t in range(T - 1, -1, -1):
    for w in range(W, -1, -1):
        DP[t][w] = Jadu[t][w % 2] + max(DP[t + 1][w:])
```

DP[t][w]ëŠ” ë‹¤ìŒ ë‘ ê°’ì˜ í•©ì´ë‹¤.

- tì´ˆì— wë§Œí¼ ì´ë™í•œ ìƒí™©ì—ì„œ ë–¨ì–´ì§€ëŠ” ìë‘ ê°œìˆ˜ (Jadu[t][w % 2])
- t+1ì´ˆì— w, w+1, w+2,â€¦Wë§Œí¼ ì›€ì§ì¸ ê²½ìš° ë°›ì„ ìˆ˜ ìˆëŠ” ìë‘ ê°œìˆ˜ ì¤‘ ìµœëŒ“ê°’ (max(DP[t + 1][w: ])

## ğŸ¥³ ë¬¸ì œ íšŒê³ 

DPìœ í˜•ì˜ ë¬¸ì œë¼ëŠ” ê²ƒì„ ì•Œê³  í’€ì–´ì„œ ê·¸ëŸ°ì§€ í•´ë‹µì„ ê¸ˆë°© ì°¾ì„ ìˆ˜ ìˆì—ˆë‹¤. ì•„ë§ˆ DP ë¬¸ì œë¼ëŠ” ì •ë³´ê°€ ì—†ì—ˆë‹¤ë©´ ìµœëŒ€ë¡œ ë°›ì„ ìˆ˜ ìˆëŠ” ê²½ìš°ë¥¼ ê·¸ë¦¼ìœ¼ë¡œ ê³„ì† ê·¸ë ¤ë´¤ì„ ê²ƒ ê°™ë‹¤. ê·¸ëŸ¬ë‹¤ê°€ Wì™€ Tì˜ ê°’ì— ë”°ë¼ ê²½ìš°ì˜ ìˆ˜ê°€ ë„ˆë¬´ ë§ë‹¤ë³´ë‹ˆ 2ì°¨ì› ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„í•´ì•¼ í•  ê²ƒì´ë¼ ìƒê°í•˜ê³  DPë¡œ ì ‘ê·¼í•  ê²ƒ ê°™ë‹¤.


# 118667: ë‘ í í•© ê°™ê²Œ ë§Œë“¤ê¸°
- ì¶œì²˜ : 2022 KAKAO TECH INTERSHIP
## ğŸ˜Â Solved Code

### ğŸ’» Code

```python
from collections import deque

def solution(queue1, queue2):
    MAX_ITERATION = 2*(len(queue1) + len(queue2))
    answer = 0
    q1, q2 = deque(queue1), deque(queue2)
    q1_sum, q2_sum = q1_sum_orig, q2_sum_orig = sum(q1), sum(q2)
    if (q1_sum + q2_sum) % 2 == 1:
        return -1
    while q1 and q2 and (answer < MAX_ITERATION):
        if q1_sum == q2_sum:
            break
        elif q1_sum > q2_sum:
            elem = q1.popleft()
            q2.append(elem)
            q1_sum -= elem
            q2_sum += elem
        elif q1_sum < q2_sum:
            elem = q2.popleft()
            q1.append(elem)
            q2_sum -= elem
            q1_sum += elem
        answer += 1
        
    if len(q1) == 0 or len(q2) == 0 or answer == MAX_ITERATION:
        answer = -1
    return answer
```

### â—ï¸ ê²°ê³¼

ì„±ê³µ

### ğŸ’¡Â ì ‘ê·¼

ìš°ì„  ë¶ˆê°€ëŠ¥í•œ ê²½ìš°ë¥¼ ìƒê°í•´ë´¤ë‹¤. ë‘ íì˜ í•©ì´ í™€ìˆ˜ë©´ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ ì´ë¥¼ êµ¬í˜„í–ˆë‹¤.

ë‘ í ì¤‘ í•©ì´ í° ìª½ì—ì„œ popì„ í•´ì„œ ì‘ì€ìª½ì— appendë¥¼ í•œë‹¤. ê·¸ë¦¬ê³  ê° íì˜ í•©ì´ ê°™ì•„ì§ˆ ë•Œ ê¹Œì§€ ë°˜ë³µí•˜ë©´ ë  ê²ƒì´ë¼ ìƒê°í–ˆë‹¤.

ì´ ê³¼ì •ì—ì„œ while ë£¨í”„ë¥¼ ì‚¬ìš©í–ˆëŠ”ë°, í•œ iterationë§ˆë‹¤ pop / push ê°€ ë°œìƒí•œë‹¤. ê·¸ë¦¬ê³  ë§¤ iterationë§ˆë‹¤ `sum(queue)`ë¡œ íì˜ í•©ì„ ê³„ì‚°í•˜ì§€ ì•Šê³  `q1_sum`, `q2_sum` ì„ ê´€ë¦¬í•˜ë©° íì˜ í•©ì„ ê³„ì‚°í–ˆë‹¤. ê·¸ë¦¬ê³  ì£¼ì–´ì§„ queue1, queue2ë¥¼ dequeë¡œ ë§Œë“¤ì–´ pop / push ì—°ì‚°ì„ ì§„í–‰í–ˆë‹¤. ì´ìœ ëŠ” ì•„ë˜ì™€ ê°™ë‹¤

- dequeëŠ” listì™€ ë‹¬ë¦¬ double linked listë¡œ êµ¬í˜„ë˜ì–´ìˆì–´ popleft()ê°€ O(1)ì´ê¸° ë•Œë¬¸
- sum(queue)ëŠ” O(n)ì˜ ì‹œê°„ë³µì¡ë„ê°€ ê±¸ë¦´ ê²ƒìœ¼ë¡œ ì˜ˆìƒë˜ë¯€ë¡œ ì´ë¥¼ ì¤„ì´ê¸° ìœ„í•¨

ë§Œì•½ q1, q2ì¤‘ ì–´ëŠ í•˜ë‚˜ê°€ ë¹„ì—ˆë‹¤ë©´ whileë¬¸ì„ íƒˆì¶œí•˜ê³  -1ì„ ë°˜í™˜í•œë‹¤.

ê·¸ëŸ¼ì—ë„ ì¼ë¶€ ì¼€ì´ìŠ¤ê°€ ì‹œê°„ì´ˆê³¼ê°€ ë–´ë‹¤. ì•„ë§ˆ ë¬´í•œë£¨í”„ì— ë¹ ì§€ëŠ” ì˜ˆì™¸ê°€ ì¡´ì¬í•  ê²ƒì´ë¼ ìƒê°í–ˆë‹¤. ì¢€ ë” ì˜ˆì‹œë¥¼ ìƒê°í•´ë³´ê³  ì•„ë˜ ì¼€ì´ìŠ¤ë¥¼ ë°œê²¬í–ˆë‹¤.

```python
queue1 = [5]
queue2 = [5,2]
```

ì´ ì˜ˆì œëŠ” ë£¨í”„ë¥¼ ë¹ ì ¸ë‚˜ì˜¤ì§€ ëª»í•œë‹¤. printë¥¼ ì¢€ ì°ì–´ë³´ë‹ˆ push / popì„ í•˜ë‹¤ ì› ìƒíƒœë¡œ ëŒì•„ì˜¤ëŠ” ì‚¬ì´í´ì„ ë°œê²¬í–ˆë‹¤. ì›ìƒíƒœë¡œ ëŒì•„ì˜¤ë©´ ë”ì´ìƒ ë³¼ í•„ìš”ê°€ ì—†ìœ¼ë¯€ë¡œ ë£¨í”„ë¥¼ íƒˆì¶œí•  ìˆ˜ ìˆë‹¤.

ë”°ë¼ì„œ ëª¨ë“  ì›ì†Œê°€ popëë‹¤ê°€ pushë˜ëŠ” ê°œìˆ˜ë¥¼ ì„¸ë©´ `2*(len(queue1) + len(queue2))` ê°€ ëœë‹¤. ì´ë¥¼ MAX_ITERATIONìœ¼ë¡œ ë‘ê³  íƒˆì¶œ ì¡°ê±´ì„ ì¶”ê°€í•˜ë‹ˆ ë¬¸ì œê°€ í•´ê²°ëë‹¤.

## ğŸ¥³ ë¬¸ì œ íšŒê³ 

ì‘ë…„ ì¹´ì¹´ì˜¤ í…Œí¬ ì¸í„´ì‹­ì— ì§€ì›í•´ì„œ ì‹¤ì „ìœ¼ë¡œ í’€ì–´ë³¸ ë¬¸ì œë‹¤. ì´ë²ˆì— ë¬¸ì œë¥¼ í’€ê³  ê·¸ ë‹¹ì‹œë¥¼ íšŒê³ í•´ë³´ë‹ˆ, ê°™ì€ ì§€ì ì—ì„œ ë§‰í˜”ë‹¤. ë°”ë¡œ ë¬´í•œ ë£¨í”„ë¥¼ ë„ëŠ” ì¼€ì´ìŠ¤ë¥¼ ì–´ë–»ê²Œ í•´ê²°í•  ì§€ì— ëŒ€í•œ ê²ƒì´ë‹¤. ê·¸ ë•ŒëŠ” ëŒ€ëµ `3*queue1` ìœ¼ë¡œ MAX_ITERATIONì„ ì„¤ì •í–ˆë‹¤. ì‚¬ì‹¤ ì´ë²ˆì— í’€ ë•ŒëŠ” ë‚˜ë¦„ ê·¼ê±°ëŠ” ìˆì§€ë§Œ í™•ì‹ ì´ ì•ˆ ì„°ë‹¤.


# 150365: ë¯¸ë¡œ íƒˆì¶œ ëª…ë ¹ì–´
- ì¶œì²˜ : 2023 KAKAO BLIND
## ğŸ˜Â Solved Code

### ğŸ’» Code

```python
import sys
sys.setrecursionlimit(10000)

dx = {
    'd': 1,
    'l': 0,
    'r': 0,
    'u': -1
}

dy = {
    'd': 0,
    'l': -1,
    'r': 1,
    'u': 0
}
def manhattan_distance(p1,p2):
    (x1,y1), (x2,y2) = p1, p2
    return abs(x1-x2) + abs(y1-y2)

def is_impossible(p1,p2,k):
    man_d = manhattan_distance(p1,p2)
    if man_d > k: # ìµœë‹¨ê²½ë¡œë³´ë‹¤ kê°€ ì‘ì„ ë•Œ
        return True
    return man_d % 2 != k % 2 # í™€ìˆ˜ / ì§ìˆ˜ ë²ˆì— ê°ˆ ìˆ˜ ìˆëŠ”ì§€ ì—¬ë¶€

def solution(n, m, x, y, r, c, k):
    global answer
    global end
    global K
    K = k
    answer = ""
    start, end = (x,y), (r,c)
    if is_impossible(start, end, k):
        return "impossible"
    
    def inside_boundary(x,y):
        return (1 <= x <= n) and (1 <= y <= m)
    
    def dfs(x,y,moves):
        global answer
        if len(moves) == K:
            if (x == end[0]) and (y == end[1]):
                answer = moves # ì •ë‹µ ì €ì¥ ë° dfs ì¢…ë£Œ
                return True
            else:
                return False
        steps_to_go = K - len(moves) # ë‚¨ì€ step
        shortest_path_len = manhattan_distance((x,y),end) # í˜„ìœ„ì¹˜ ê¸°ì¤€ ìµœë‹¨ê±°ë¦¬
        if steps_to_go < shortest_path_len:
            return False
        
        for direction in ['d','l','r','u']:
            nx = x + dx[direction]
            ny = y + dy[direction]
            if inside_boundary(nx,ny):
                solved = dfs(nx,ny,moves+direction)
                if solved:
                    return True
        return False
    dfs(x,y,"")
    return answer
```

### â—ï¸ ê²°ê³¼

ì–´ë µê²Œ ì„±ê³µ

### ğŸ’¡Â ì ‘ê·¼

ë°±íŠ¸ë˜í‚¹ì„ ê³ë“¤ì¸ DFSë¡œ ì ‘ê·¼í–ˆë‹¤.

ë¨¼ì € ì¼ë¶€ ì¼€ì´ìŠ¤ëŠ” impossible ì—¬ë¶€ë¥¼ ë°”ë¡œ íŒë‹¨í•  ìˆ˜ ìˆë‹¤. ì´ë¥¼ `is_impossible` ì—ì„œ ì²˜ë¦¬í–ˆë‹¤.

start â†’ end ê¹Œì§€ì˜ ë§¨í•˜íƒ„ ê±°ë¦¬(ìµœë‹¨ê±°ë¦¬)ê°€ k ë³´ë‹¤ í¬ë‹¤ë©´ ì• ì´ˆì— ë¶ˆê°€ëŠ¥í•˜ë‹¤. ë˜ëŠ” ë§¨í•˜íƒ„ ê±°ë¦¬ì™€ kê°€ í™€ìˆ˜ / ì§ìˆ˜ë¡œ ì„œë¡œ ë‹¤ë¥´ë‹¤ë©´ ë„ë‹¬ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì´ëŠ” ëª‡ ë²ˆ ì†ìœ¼ë¡œ ê·¸ë¦¬ë©° ì‹œë®¬ë ˆì´ì…˜ í•´ë³´ë©´ ì•Œ ìˆ˜ ìˆë‹¤.

dfsë¡œ k depth ë§Œí¼ ì¬ê·€íƒìƒ‰ì„ ì§„í–‰í•˜ê³ , depth kì—ì„œ endì— ë„ë‹¬í–ˆëŠ”ì§€ í™•ì¸í•œë‹¤.

ì´ ë•Œ ì•„ì£¼ ì¤‘ìš”í•œ ê²ƒì€ ë™ì„œë‚¨ë¶ íƒìƒ‰ì˜ ìˆœì„œë¥¼ `[â€™dâ€™, â€˜lâ€™, â€˜râ€™, â€˜uâ€™]` ë¡œ í•´ì•¼í•œë‹¤!! ì™œëƒí•˜ë©´ ë¬¸ì œì—ì„œ endë¡œ kë²ˆë§Œì— ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œì¤‘ ì‚¬ì „ìˆœìœ¼ë¡œ ê°€ì¥ ë¹ ë¥¸ ê²½ë¡œë¥¼ ì¶œë ¥í•˜ë¼ê³  í–ˆê¸° ë•Œë¬¸ì´ë‹¤. ì´ë ‡ê²Œ íƒìƒ‰ì„ ì§„í–‰í•˜ë‹¤ kë²ˆì§¸ì— endì— ìµœì´ˆë¡œ ë„ë‹¬í•˜ë©´, ê·¸ ê²½ë¡œê°€ ì •ë‹µì´ ë ìˆ˜ë°–ì— ì—†ë‹¤. ê·¸ëŸ¼ íƒìƒ‰ì„ ì¦‰ì‹œ ì¢…ë£Œí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì—°ì‚°ëŸ‰ì„ í¬ê²Œ ì¤„ì¼ ìˆ˜ ìˆë‹¤. ì¦‰ì‹œ ì¢…ë£Œë¥¼ ìœ„í•´ callerëŠ” callee ê²°ê³¼ì˜ ì˜í–¥ì„ ë°›ì•„ì•¼ í•œë‹¤. ë”°ë¼ì„œ dfs í•¨ìˆ˜ëŠ” ë‹µì„ ì°¾ìœ¼ë©´ True, ì•„ë‹ˆë©´(íƒìƒ‰ì„ ê³„ì† í•´ì•¼ í•œë‹¤ë©´) Falseë¥¼ ë°˜í™˜í•œë‹¤. 

```python
if inside_boundary(nx,ny):
		solved = dfs(nx,ny,moves+direction)
    if solved:
		    return True
```

ê·¸ë¦¬ê³  dfs ë‚´ë¶€ì—ì„œ ì¬ê·€í˜¸ì¶œ ê²°ê³¼ì— ë”°ë¼ ì¦‰ì‹œ íƒˆì¶œí•  ìˆ˜ ìˆê²Œ ì²˜ë¦¬í•´ë‘ì—ˆë‹¤.

ì—°ì‚°ëŸ‰ì„ ë” ì¤„ì´ê¸° ìœ„í•´ ë°±íŠ¸ë˜í‚¹ì„ ì–¹ì–´ì¤€ë‹¤. í˜„ ìœ„ì¹˜ì—ì„œ ë‚¨ì€ ì´ë™íšŸìˆ˜ë¡œ endê¹Œì§€ ë„ë‹¬í•  ìˆ˜ ì—†ëŠ”ê²Œ ìëª…í•˜ë©´ ë” íƒìƒ‰ì„ í•  ì´ìœ ê°€ ì—†ë‹¤.

```python
steps_to_go = K - len(moves) # ë‚¨ì€ step
shortest_path_len = manhattan_distance((x,y),end) # í˜„ìœ„ì¹˜ ê¸°ì¤€ ìµœë‹¨ê±°ë¦¬
if steps_to_go < shortest_path_len:
    return False
```

`moves` ì—ëŠ” í˜„ì¬ê¹Œì§€ ì˜¨ ê²½ë¡œ(ex. â€˜drrldâ€™)ë¥¼ stringìœ¼ë¡œ ì €ì¥í•˜ê³  ìˆë‹¤. Kë²ˆ ì´ë™í•˜ê¸° ìœ„í•´ ë‚¨ì€ step ìˆ˜ì™€, í˜„ ìœ„ì¹˜ì—ì„œ ìµœë‹¨ê±°ë¦¬ê¹Œì§€ì˜ ê¸¸ì´ë¥¼ ë¹„êµí•˜ë©° dfs ì¤‘ê°„ì—ì„œ pruningì„ ì§„í–‰í•  ìˆ˜ ìˆë‹¤.

## ğŸ¥³ ë¬¸ì œ íšŒê³ 

ì²˜ìŒì—ëŠ” ë³€ìˆ˜ì˜ ë²”ìœ„ ì¡°ê±´ì„ ë³´ê³  ë§‰ì—°í•˜ê²Œ DFS/BFSë¡œ ì ‘ê·¼í•˜ë©´ ì‹œê°„ ì´ˆê³¼ê°€ ëœ° ê²ƒì´ë¼ ìƒê°í–ˆë‹¤. ë”°ë¼ì„œ ì ‘ê·¼ì„ ë°”ê¿” ê·¸ë¦¬ë”” ë°©ì‹ìœ¼ë¡œ ìƒê°í–ˆë‹¤. ê·¸ëŸ°ë° 1ì‹œê°„ ë„˜ê²Œ ê³ ë¯¼í•´ë„ ë„ì €íˆ ë°©ë²•ì´ ì•ˆë– ì˜¬ë¼ í¬ê¸°í–ˆë‹¤. ë‹¹ì‹œì— í˜„ìˆ˜í˜•ì´ë‘ ë¬¸ì œë¥¼ ê°™ì´ í’€ê³ ìˆì—ˆê³ , ë‚˜ì™€ ë‹¤ë¥´ê²Œ DFSë¡œ ì ‘ê·¼í–ˆë‹¤. ì¼ë¶€ ë°±íŠ¸ë˜í‚¹ ì¡°ê±´ì„ ì¶”ê°€í•˜ë©´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ì•„ì„œ ë°±ì§€ ìƒíƒœì—ì„œ ë‹¤ì‹œ ì‹œì‘í–ˆê³  ì–´ë µê²Œ í’€ì—ˆë‹¤.

ì•„ë§ˆ ì‹¤ì „ì´ì—ˆë‹¤ë©´ ê³ ë¯¼í•˜ë‹¤ ìŠ¤í‚µí–ˆì„ ê²ƒ ê°™ì€ ë¬¸ì œë‹¤. â€œimpossibleâ€ì„ ì¶œë ¥í•˜ëŠ” ì—¬ëŸ¬ ì˜ˆì™¸ ì¼€ì´ìŠ¤ë¥¼ ê°ê° ì²˜ë¦¬í•´ì•¼ í•˜ë©°, ì ë‹¹íˆ pruningê¹Œì§€ í•´ì•¼í–ˆë˜ ê¹Œë‹¤ë¡œìš´ ë¬¸ì œì˜€ë‹¤.