# 2주차

## [1. 백준\_16234 (인구이동)](https://www.acmicpc.net/problem/16234)

### 아이디어

1. board 의 한 지점에 대해 dfs 를 수행한다. 인접노드의 인구차이가 L 이상 R 이하 && 미방문노드 일때만 인접노드를 방문한다.
2. 한 지점에 대해 dfs 가 끝나면 방문한 노드의 인구 평균을 계산하고 인구이동을 시킨다.
3. 전체 board 에 대해 1,2 를 반복한다.
4. 전체 board 에 대해 1 ~ 3 과정이 끝나면 인구이동 하루가 끝난다.
5. 다시 전체 board 에 대해 새롭게 dfs 를 수행하는데, dfs 가 수행되지 않으면 전체 로직을 종료한다.

### 회고 및 코멘트

- 인구이동 계산(평균 계산) 언제할지에 대한 고민

  1.  전체 board 의 모든 지점에 대해 dfs 끝나고나서 인구이동(평균계산)
      => 가장 직관적이지만, 여러 연합국에 대한 인구정보를 담아줄 별도의 자료구조가 필요하다.  
       나는 이 과정이 구현을 좀 더 어렵게하고 번거롭다고 느껴졌다.
  2.  한 지점에 대해 dfs 끝나고나서 인구이동(평균계산)
      => 전체 board 가 아닌 한 지점에 대해 가능한 연합국을 탐색하고 dfs 가 종료되면 바로 평균을 계산하고 인구이동을 시킨다.  
      처음에 이 방식으로 하면 인구 이동을 하는 중간에 인구 수 변동이 생기니까 국경선 계산 시 꼬이는 것 아닌가? 하는 의문이 들었지만 결과적으로는 상관없다.  
      dfs 시 방문여부를 체크하기 때문에 중간에 인구 수를 변동해도 상관이 없다.
      나는 2번 방식을 택했다.

## [2. 백준\_1744 (수 묶기)](https://www.acmicpc.net/problem/1744)

### 아이디어

우선 내림차순 정렬을 한다.

그 후 양수 그룹와 양수가 아닌 그룹(0, 음수) 로 나누어서 생각한다.

- 양수 그룹:

  - 1이 아닌 양수 등장 시 : 곱하기
  - 1 등장 시 : 더하기

- 양수가 아닌 그룹:
  - 양수가 아닌 수 (0 또는 음수) : 곱하기

### 회고 및 코멘트

- 예외경우가 좀 많이 나왔다. 내가 짠 로직으로는 양수가 하나 남았을 때라던가 인덱스 계산에서 예외경우가 좀 나왔고, TC 는 통과했는데 히든TC 에서 틀린 경우가 몇 개 있어서 게시판 반례를 통해 해결했다.
- 현재 로직은 너무 지저분한 것 같아서 다시 짜려고 함 ( deque 를 이용해서 수를 하나씩 꺼내면서 판단하면 로직이 좀 간결해질 것 같음 )

## [3. 프로그래머스\_개인정보 수집 유효기간](https://school.programmers.co.kr/learn/courses/30/lessons/150370)

### 아이디어

날짜를 `YYMMDD` 문자열로 변경해서 비교했다.

### 회고 및 코멘트

- 그렇게 어려운 부분은 없었다.

## [4. 프로그래머스\_표현 가능한 이진트리](https://school.programmers.co.kr/learn/courses/30/lessons/150367)

### 아이디어

[전체 로직]

1. 십진수를 이진수로 변환한다.
2. 변환된 이진수를 `2^n - 1` 자릿수의 이진수로 변환한다.
   ㄴ 포화이진트리 형태의 이진수로 만들기 위함임
3. `2^n -1` 자릿수의 이진수가 포화이진트리로 만들 수 있는 이진수인지 체크한다.

[분할정복 로직]
포화이진트리로 만들 수 있는 이진수인지 체크하는 함수

이진수의 가운데 수가 1 : 왼쪽그룹과 오른쪽그룹으로 분할해서 재귀적으로 검사
이진수의 가운데 수가 0 : 왼쪽그룹과 오른쪽그룹이 모두 0 이여야 한다. ( 1이 있으면 안 된다.)

1. 한 자리 이진수면 `return True` 로 함수 콜 종료
2. 이진수의 가운데 수가 1 이면 => 왼쪽그룹, 오른쪽그룹 분할정복
3. 이진수의 가운데 수가 0 이면 => 왼쪽그룹, 오른쪽그룹 모두 0 인지 검사
4. 왼쪽그룹과 오른쪽그룹 둘 다 포화이진트리로 만들 수 있으면 `return True`으로 함수 콜 종료, 그렇지 않다면 `return False`

### 회고 및 코멘트

- 분할정복 문제를 오랜만에 풀어봐서 좀 까다로웠다.
- 아이디어는 구상했는데, 코드 구현 과정에서 시간이 오래 걸렸다.
- 하나의 함수에서 단일 기능만을 수행하도록 잘 짠 것 같다.
