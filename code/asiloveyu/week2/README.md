## backjoon-16234

과거에 알고리즘 공부 전 풀었던 문제인데, 다시 풀어보니 쉽게 풀려서 뿌듯했습니다.
다만, 여전히 구현 상 잡다한 오류가 발생해 개선이 필요한 부분이 많습니다.

### 어려웠던 부분

- 잘못된 인덱스, 함수 인자 관리로 계속해서 무한루프가 발생해 어려움이 있었습니다.

### 풀이 방법

- DFS에서 recursion을 이용해 모든 좌표로부터 포함 가능한 좌표들을 stack에 쌓는 형태로 풀이했습니다.
- 포함가능한 좌표를 배열로 반환한 뒤 단순하게 평균을 구해 적용하는 방법으로 풀이했습니다.

### 풀이 로직

[1] 매 시행마다 모든 좌표에 대해 탐색합니다.
[2] 각 좌표를 기준으로 탐색하지 않은 좌표가 있을 시 이를 stack에 쌓아 탐색합니다.
[3] 탐색한 좌표 중 조건에 일치하는 경우 ally에 포함해 반환합니다.
[4] 최종적으로 반환한 ally에 대해 평균을 구하고 적용합니다.
[5] 모든 좌표의 ally의 길이가 1 (자기자신)인 경우 시행을 종료합니다.

## backjoon-1744

기본 정렬 알고리즘을 사용하면 쉽게 풀이할 수 있는 문제 같습니다.
물론, 작은 예외 케이스들이 많아 고민에 시간 소모가 필요한 것 같네요.
책의 내용을 참조해 counting sort를 구현해보았습니다.

### 어려웠던 부분

- 오류 케이스를 제공해주지 않는 백준 특성 상 오류 케이스를 찾아내기가 어려웠습니다.

### 풀이방법

[1] 내림차순으로 배열을 정렬합니다. (Counting Sort)
[2] 길이가 1인 에지케이스를 예외처리 합니다.
[3] 양 끝에서 출발하는(양수, 음수) 포인터를 가운데로 2칸씩 이동하며 곱한 뒤 더합니다.
[4] 좌측 양수 포인터에 양수가 1칸 남아있는 경우 이를 더합니다.
* 1개의 양수 값의 최대 값은 항상 덧셈
[5] 중간 영역이 한칸 남은 경우 이를 더합니다.
* 한칸 남은 경우 (0 또는 음수), 최대 값은 항상 덧셈

## programmers-150370

단순하게 풀이할 수 있는 문제로, string 조작에 관한 문제 같습니다.
사칙연산에 오류가 없다면 무난히 통과할 수 있는 것 같습니다.

### 어려웠던 부분

- 날짜로 변환하여 계산하다보니 계산을 통한 추적이 어려웠습니다.

### 풀이방법

[1] 조건 내 날짜를 일(day) 기준으로 변경합니다
[2] 오늘 날짜를 일(day) 기준으로 변경합니다
[3] 일(day) 기준으로 기준일자와 조건일자, 그리고 오늘 날짜 간 차이를 구한 뒤 결과를 반환합니다

## programmers-150367

포화이진트리 여부를 탐색하는 문제로 recursion을 이용해 풀이할 수 있습니다.
다만, 문제 풀이에 실패해 솔루션을 참조했으며 그 이유를 아직 이해하지 못했습니다.

### 어려웠던 부분

- recursion의 index를 잘못 결정할 경우 stack overflow가 발생해 디버깅에 어려움이 있었습니다.
- 포화 이진트리로 만드는 과정을 이해하는데 어려움이 있었습니다.

### 풀이방법

[1] 입력 배열의 각 값을 순환합니다.
[2] 이진 트리를 포화 이진 트리로 만듭니다.
[3] 각 포화 이진트리에 대해 패턴 일치여부를 recursion으로 나누어 탐색합니다.
[4] top-down으로 실행하며 최종적으로 root node의 결과를 반환합니다.

### 미해결 질문

길이가 (2의 급수 - 1)에 미달하는 이진수에 대해 왜 앞에 0을 모두 붙이면 포화이진트리가 되고
뒤에 0을 모두 붙이면 포화이진트리가 되지 않는가?