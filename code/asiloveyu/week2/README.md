## backjoon-16234

과거에 알고리즘 공부 전 풀었던 문제인데, 다시 풀어보니 쉽게 풀려서 뿌듯했습니다.
다만, 여전히 구현 상 잡다한 오류가 발생해 개선이 필요한 부분이 많습니다.

### 어려웠던 부분

- 잘못된 인덱스, 함수 인자 관리로 계속해서 무한루프가 발생해 어려움이 있었습니다.

### 풀이 방법

- DFS에서 recursion을 이용해 모든 좌표로부터 포함 가능한 좌표들을 stack에 쌓는 형태로 풀이했습니다.
- 포함가능한 좌표를 배열로 반환한 뒤 단순하게 평균을 구해 적용하는 방법으로 풀이했습니다.

### 풀이 로직

[1] 매 시행마다 모든 좌표에 대해 탐색합니다.
[2] 각 좌표를 기준으로 탐색하지 않은 좌표가 있을 시 이를 stack에 쌓아 탐색합니다.
[3] 탐색한 좌표 중 조건에 일치하는 경우 ally에 포함해 반환합니다.
[4] 최종적으로 반환한 ally에 대해 평균을 구하고 적용합니다.
[5] 모든 좌표의 ally의 길이가 1 (자기자신)인 경우 시행을 종료합니다.

## backjoon-1744

기본 정렬 알고리즘을 사용하면 쉽게 풀이할 수 있는 문제 같습니다.
물론, 작은 예외 케이스들이 많아 고민에 시간 소모가 필요한 것 같네요.
책의 내용을 참조해 counting sort를 구현해보았습니다.

### 어려웠던 부분

- 오류 케이스를 제공해주지 않는 백준 특성 상 오류 케이스를 찾아내기가 어려웠습니다.

### 풀이방법

[1] 내림차순으로 배열을 정렬합니다. (Counting Sort)
[2] 길이가 1인 에지케이스를 예외처리 합니다.
[3] 양 끝에서 출발하는(양수, 음수) 포인터를 가운데로 2칸씩 이동하며 곱한 뒤 더합니다.
[4] 좌측 양수 포인터에 양수가 1칸 남아있는 경우 이를 더합니다.
* 1개의 양수 값의 최대 값은 항상 덧셈
[5] 중간 영역이 한칸 남은 경우 이를 더합니다.
* 한칸 남은 경우 (0 또는 음수), 최대 값은 항상 덧셈