생각보다 문제 풀이가 오려걸려 급하게 문제부터 풀다보니 리드미 작성이 늦었습니다.
다음부터는 한 문제씩 풀이와 리드미 작성을 병행해 개선하도록 하겠습니다.

### backjoon-2212

가장 먼저 풀이한 문제로 백준 환경에서 node 기반 입출력 다루느라 애를 먹었습니다.
문제는 기본적인 Greedy로 풀이했습니다.

#### 어려웠던 부분

- 중계기의 너비가 0인 경우를 고려하는 것이 어려웠습니다.
- 제거해야할 거리를 구한다는 관점으로 접근해 어려움이 있었습니다.

#### 풀이 방법

- 주어진 구간을 분할한다는 관점을 터득해 풀이할 수 있었습니다.
- (중계기 갯수 - 1) 만큼 구간을 제거하면 중계기 개수만큼 구간이 분할된다는 사실을 토대로 풀이했습니다.

#### 풀이 로직

[1] 센서를 1차원 공간에 좌표 순서대로 정렬합니다.
[2] 센서 간 위치를 빼서 각 센서간 구간을 구합니다.
[3] 구간을 내림차순으로 나열해서 (중계기 갯수 - 1)만큼 제거한 뒤 나머지를 더해 반환합니다.

### backjoon-15683

NA

### programmers-150368

할인율이 10단위로 증가한다는 사실(10, 20, 30, 40)을 읽지 못하고
1단위로 증가시켜 DFS로 탐색, 정답보다 더 최적화된 비율을 구하면서 해맸습니다.
문제를 자세히 읽어야겠습니다.

#### 어려웠던 부분

- 매 회차에 가장 optimal한 결과(local optium)를 탐색하는 DFS가 global optimum인지 알 수 없었습니다.
- 중복 순열을 구현하는데 (반복문 사용시 최대 7중 루프) 어려움이 있었습니다.

#### 풀이 방법

- 중복 순열을 미리 구해 가능한 모든 조합에 대해 최적값을 도출합니다.
- 모든 조합에 대해서 (1) 구독자 수 (2) 매출액을 기준으로 global optium을 탐색합니다.

#### 풀이 로직

[1] 할인율의 중복 순열을 구합니다. (최대 4^7개)
[2] 순열 내 각 값에 대해 모두 값을 구하며, 최대 값을 구합니다.
[3] 결과를 반환합니다. 

### programmers-150369

가장 먼 집부터 방문한다는 Greedy 로직은 단순하나
공간이 남을 경우 이 공간을 어떻게 넘길 것인지 고민을 하게된 문제였습니다.

#### 어려웠던 부분
- 공간(cap)이 남을 경우 더 가까운 집에서 짐을 챙기는 것을 어떻게 구현할 것인가.

#### 풀이 방법

- 가장 먼 집부터 차례로 방문해 짐을 나릅니다.
- 매 순환마다 옮긴 짐의 총량을 점검해 날라야 할 짐보다 크면 다음 집으로 이동합니다.

#### 풀이 로직

[1] 가장 먼 집부터 가장 가까운 집까지 순환합니다.
[2] 만일 옮긴 짐이 현재 집의 짐보다 많으면 집을 이동합니다.
[3] cap만큼 짐을 옮기고 이동거리를 더합니다.